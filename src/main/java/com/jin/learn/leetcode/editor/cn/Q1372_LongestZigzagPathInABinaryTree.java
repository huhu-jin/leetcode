//  [1372]äºŒå‰æ ‘ä¸­çš„æœ€é•¿äº¤é”™è·¯å¾„

//ç»™ä½ ä¸€æ£µä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ï¼ŒäºŒå‰æ ‘ä¸­çš„äº¤é”™è·¯å¾„å®šä¹‰å¦‚ä¸‹ï¼š 
//
// 
// é€‰æ‹©äºŒå‰æ ‘ä¸­ ä»»æ„ èŠ‚ç‚¹å’Œä¸€ä¸ªæ–¹å‘ï¼ˆå·¦æˆ–è€…å³ï¼‰ã€‚ 
// å¦‚æœå‰è¿›æ–¹å‘ä¸ºå³ï¼Œé‚£ä¹ˆç§»åŠ¨åˆ°å½“å‰èŠ‚ç‚¹çš„çš„å³å­èŠ‚ç‚¹ï¼Œå¦åˆ™ç§»åŠ¨åˆ°å®ƒçš„å·¦å­èŠ‚ç‚¹ã€‚ 
// æ”¹å˜å‰è¿›æ–¹å‘ï¼šå·¦å˜å³æˆ–è€…å³å˜å·¦ã€‚ 
// é‡å¤ç¬¬äºŒæ­¥å’Œç¬¬ä¸‰æ­¥ï¼Œç›´åˆ°ä½ åœ¨æ ‘ä¸­æ— æ³•ç»§ç»­ç§»åŠ¨ã€‚ 
// 
//
// äº¤é”™è·¯å¾„çš„é•¿åº¦å®šä¹‰ä¸ºï¼šè®¿é—®è¿‡çš„èŠ‚ç‚¹æ•°ç›® - 1ï¼ˆå•ä¸ªèŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ä¸º 0 ï¼‰ã€‚ 
//
// è¯·ä½ è¿”å›ç»™å®šæ ‘ä¸­æœ€é•¿ äº¤é”™è·¯å¾„ çš„é•¿åº¦ã€‚ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//
// è¾“å…¥ï¼šroot = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
//è¾“å‡ºï¼š3
//è§£é‡Šï¼šè“è‰²èŠ‚ç‚¹ä¸ºæ ‘ä¸­æœ€é•¿äº¤é”™è·¯å¾„ï¼ˆå³ -> å·¦ -> å³ï¼‰ã€‚
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//
// è¾“å…¥ï¼šroot = [1,1,1,null,1,null,null,1,1,null,1]
//è¾“å‡ºï¼š4
//è§£é‡Šï¼šè“è‰²èŠ‚ç‚¹ä¸ºæ ‘ä¸­æœ€é•¿äº¤é”™è·¯å¾„ï¼ˆå·¦ -> å³ -> å·¦ -> å³ï¼‰ã€‚
// 
//
// ç¤ºä¾‹ 3ï¼š 
//
// è¾“å…¥ï¼šroot = [1]
//è¾“å‡ºï¼š0
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// æ¯æ£µæ ‘æœ€å¤šæœ‰ 50000 ä¸ªèŠ‚ç‚¹ã€‚ 
// æ¯ä¸ªèŠ‚ç‚¹çš„å€¼åœ¨ [1, 100] ä¹‹é—´ã€‚ 
// 
// Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ åŠ¨æ€è§„åˆ’ äºŒå‰æ ‘ ğŸ‘ 84 ğŸ‘ 0


package com.jin.learn.leetcode.editor.cn;

import com.jin.learn.common.TreeNode;
import org.testng.annotations.Test;


public class Q1372_LongestZigzagPathInABinaryTree{
  
  
    //leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    public int longestZigZag(TreeNode root) {
         dfs(root);

        return ans;
    }



    //return å­æ ‘çš„[left, right]çš„å€¼
    private int[] dfs(TreeNode root) {
        if (root== null) return new int[]{0, 0};
        int[] subLeft = dfs(root.left);
        int[] subRight = dfs(root.right);

        int L = 0;
        if (root.left != null) {
            L = subLeft[1] + 1;
        }

        int R = 0;
        if (root.right != null) {
            R = subRight[0] + 1;
        }

        ans = Math.max(Math.max(L, R), ans);

        return new int[]{L, R};
    }

}
//leetcode submit region end(Prohibit modification and deletion)

    
    @Test
    public void testCase(){
        
    }
  
}
